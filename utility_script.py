# simple script used to generate signatures and keys
import ecies
import subprocess
import base64
from ecies import encrypt, decrypt
'''
key = ecies.utils.generate_eth_key()
priv_key = key.to_hex()
print('private key:')
print(priv_key)
pub_key = key.public_key.to_hex()
print('public key:')
print(pub_key)
'''
# generating scriptPubKey
# echo -n $PUB_KEY | xxd -r -p | openssl dgst -sha256 -binary | openssl dgst -rmd160
pub_key_string = '0x8b7b944c1a7312b0c41f1b3b780d96f9d1edb40aea5bbcd95cd591811363f151222434a1f7cd73765c5df6f94c1afc062bf32c02ca8da44ceeb781ff9d500165'
pub_key = 0x8b7b944c1a7312b0c41f1b3b780d96f9d1edb40aea5bbcd95cd591811363f151222434a1f7cd73765c5df6f94c1afc062bf32c02ca8da44ceeb781ff9d500165
# not in order to generate the OP_160 hash which wil match the stored scriptPubKey, we need to convert from string base
script_pub_key = subprocess.check_output('echo -n '+hex(int(pub_key_string, 16))+' | xxd -r -p | openssl dgst -sha256 -binary | openssl dgst -rmd160', shell=True)
script_pub_key_string = script_pub_key.decode('utf-8')
# retrieve only the hex value generated by the scriptPubKey command
script_pub_key_string = script_pub_key_string.split(' ')[1].strip()
print('scriptPubKey: {}'.format(script_pub_key_string))
priv_key = 0xa2bc5e616913c367314de49dd93bd76638411a01d2362e5a01c1418a199929fb
to_be_signed = b'\x04o\xe68\xed\xa15\xecpY\x0b\xba\xc5\x125\xc0\xae\xb40\x03\x9cr\x97\xf1)\x88M_=a\x97pc=\xdb\xad_\xf9\xb0M\xa0U\xd5\xfaL-\x8b\x14\x9b\x9f\x7f2v\xda\xff~\t\x01\xdf\xfbF\xc7\x8e\xda\x05\xf1i\xa5VU=\xe2\xba\xa6C0\xa5_\xf6\xc4\x9b\xd4;h~|\xc1\xde\xd8\xff\xf0^\xfe&G\x17\xcb\xba;8\xd8\x03\xb3\xbc\x85M\x02$\xd2YP\xe0\xa5V\x82l\x92\x1c\xd0\xe4E\x11v\xaa\"v\xabg\xbdK\xcdPR' 
# encrypted_test = ecies.encrypt(pub_key, bytes(to_be_signed, 'utf-8'))
# decrypted_test = ecies.decrypt(priv_key, encrypted_test)
# generate a signature
# msgHash = hashlib.sha3_256(test_string.encode('utf-8'))
ecies_priv_key = ecies.hex2prv(hex(priv_key))
ecies_priv_key.public_key = ecies.hex2pub(hex(pub_key))
decrypted_result = decrypt(hex(priv_key), to_be_signed)
print('decrypted eth:')
print(decrypted_result.decode('utf-8'))
signature = ecies_priv_key.sign(decrypted_result)
print('signed with private:')
print(signature)
encoded_signature = base64.b64encode(signature)
# encoded_signature = "MEQCIFE620xZO6hRsijz+RCh0cpnYdXW56VYe2ejmgBc8enaAiBtt/ovNyFMOdM6MeS6b4VAoofToEihu7d/2M0AUdlHJg=="
print('enncoded signature: ')
print(encoded_signature)
decoded_signature = base64.b64decode(encoded_signature)
print('decoded signature')
print(decoded_signature)
ecies_pub_key = ecies.hex2pub(hex(pub_key))
result = ecies_pub_key.verify(signature, decrypted_result)
if result:
    print('matched public key verification')
else:
    print('did not match public key verification')

'''
eth_k = generate_eth_key()
sk_hex = eth_k.to_hex()  # hex string
pk_hex = eth_k.public_key.to_hex()  # hex string
data = b'this is a test'
result = decrypt(sk_hex, encrypt(pk_hex, data))
print('decrypted eth:')
print(result.decode('utf-8'))
secp_k = generate_key()
sk_bytes = secp_k.secret  # bytes
pk_bytes = secp_k.public_key.format(True)  # bytes
sec_res = decrypt(sk_bytes, encrypt(pk_bytes, data))
print('decrypted sec:')
print(sec_res.decode('utf-8'))
'''